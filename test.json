{
  "address": "0x97d440A74a384161b54b41A137e246FC235891C9",
  "chain": "11155111",
  "files": {
    "metadata.json": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"balanceOf(address)\":{\"notice\":\"Read only function to retrieve the token balance of a given account. The `view` modifier indicates that it doesn't modify the contract's state, which allows us to call it without executing a transaction.\"},\"constructor\":{\"notice\":\"Contract initialization.\"},\"transfer(address,uint256)\":{\"notice\":\"A function to transfer tokens. The `external` modifier makes a function *only* callable from *outside* the contract.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Token.sol\":\"Token\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Token.sol\":{\"keccak256\":\"0xb029ce134c7c36f540957b73e1584ab198ad7fa8611dd54b24166058ae203f29\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://628bfb741038a97b911f48b3a3d27ac95e3c220eb0e68e6035386e775d25c760\",\"dweb:/ipfs/QmU4JK1Pb7jA6wT1hKZVjzUJK37nBGNkUTaNCYjoAfrNtL\"]}},\"version\":1}",
    "Token.sol": "//SPDX-License-Identifier: UNLICENSED\n\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.0;\n\n\n// This is the main building block for smart contracts.\ncontract Token {\n    // Some string type variables to identify the token.\n    string public name = \"Kakarots\";\n    string public symbol = \"KKT\";\n\n    // The fixed amount of tokens, stored in an unsigned integer type variable.\n    uint256 public totalSupply = 1000000;\n\n    // An address type variable is used to store ethereum accounts.\n    address public owner;\n\n    // A mapping is a key/value map. Here we store each account's balance.\n    mapping(address => uint256) balances;\n\n    // The Transfer event helps off-chain applications understand\n    // what happens within your contract.\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * Contract initialization.\n     */\n    constructor() {\n        // The totalSupply is assigned to the transaction sender, which is the\n        // account that is deploying the contract.\n        balances[msg.sender] = totalSupply;\n        owner = msg.sender;\n    }\n\n    /**\n     * A function to transfer tokens.\n     *\n     * The `external` modifier makes a function *only* callable from *outside*\n     * the contract.\n     */\n    function transfer(address to, uint256 amount) external {\n        // Check if the transaction sender has enough tokens.\n        // If `require`'s first argument evaluates to `false` then the\n        // transaction will revert.\n        require(balances[msg.sender] >= amount, \"Not enough tokens\");\n\n        // Transfer the amount.\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        // Notify off-chain applications of the transfer.\n        emit Transfer(msg.sender, to, amount);\n    }\n\n    /**\n     * Read only function to retrieve the token balance of a given account.\n     *\n     * The `view` modifier indicates that it doesn't modify the contract's\n     * state, which allows us to call it without executing a transaction.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n"}"
  },
  "creatorTxHash": "0x29afd8061a069aa8645c8435773976a4aa57822c7cea4f3f5885590bbc411084",
  "chosenContract": "Token"
}

